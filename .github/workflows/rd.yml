name: Release Go App, Binaries, and Docker Image

# Trigger this workflow ONLY on pushes of tags starting with 'v'
# OR when manually triggered via the Actions UI
on:
  push:
    tags:
      - 'v*' # Trigger on version tags like v1.0.0
  workflow_dispatch: # Allow manual triggering

env:
  IMAGE_NAME: biu_email         # Your application/image base name
  GO_VERSION: '1.21'           # Specify the Go version to use
  # The Go binary name expected/produced. Adjust if needed.
  # Using IMAGE_NAME for consistency, assuming go build produces 'biu_email'
  GO_BINARY_NAME: biu_email

jobs:
  # Job 1: Build Go Binaries for Linux
  build-go:
    name: Build Go Binaries
    runs-on: ubuntu-latest
    outputs:
      # Pass the artifact name to the release job
      binary_artifact_name: ${{ steps.artifact_upload.outputs.artifact-name }}
      # Pass the tag name (extracted cleanly) to the release job
      tag_name: ${{ steps.extract_tag.outputs.tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        # Fetch all history for all tags and branches, needed for release notes if using git history later
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      # --- Cache Fix: Clean cache dir BEFORE restore attempt ---
      - name: Clean Go module cache before restore
        run: go clean -modcache

      - name: Go Cache
        id: go-cache # Give the cache step an ID for potential cache hit checking
        uses: actions/cache@v4
        with:
          # Cache both downloaded modules and build cache
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
          # Improved key including Go version
          key: ${{ runner.os }}-go-${{ env.GO_VERSION }}-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-${{ env.GO_VERSION }}-
            ${{ runner.os }}-go-

      # --- Ensure modules are present after cache step ---
      - name: Download Go Modules (if cache miss)
        # This runs fast on cache hit, ensures modules exist on miss
        if: steps.go-cache.outputs.cache-hit != 'true'
        run: go mod download

      - name: Build Go Binary (Linux AMD64)
        run: |
          echo "Building for linux/amd64..."
          # Ensure output directory exists
          mkdir -p ./bin
          # Build statically linked binary (usually more portable) if possible/needed
          # Add ldflags to strip debug info and potentially set version info
          # Example: go build -ldflags="-s -w -X main.version=${{ steps.extract_tag.outputs.tag }}" ...
          GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -v -ldflags="-s -w" -o ./bin/${{ env.GO_BINARY_NAME }}-linux-amd64 .
          echo "Build complete."
          ls -lh ./bin

      # --- Extract tag name cleanly for use in artifact name and outputs ---
      - name: Extract tag name
        id: extract_tag
        # GITHUB_REF for tags is 'refs/tags/vX.Y.Z', we just want 'vX.Y.Z'
        # For workflow_dispatch, use 'manual-run' or similar as a fallback if needed
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          if [[ -z "$TAG_NAME" || "$TAG_NAME" == "$GITHUB_REF" ]]; then
            # Handle case where it's not a tag push (e.g., manual run)
            # You might want a different behavior for manual runs
            echo "Not a tag push or invalid tag format. Using 'manual' for tag."
            TAG_NAME="manual-${{ github.run_id }}" # Example fallback
          fi
          echo "TAG_NAME=${TAG_NAME}"
          echo "tag=${TAG_NAME}" >> $GITHUB_OUTPUT

      - name: Upload Go Binaries Artifact
        id: artifact_upload
        uses: actions/upload-artifact@v4
        with:
          # Use the extracted tag name for the artifact
          name: go-binaries-${{ steps.extract_tag.outputs.tag }}
          path: ./bin/* # Upload all files in the bin directory
          # Set artifact name in output for the release job
          retention-days: 7 # Optional: Keep artifacts for a week


  # Job 2: Build and Push Docker Image (Depends on Code Checkout Only)
  build-and-push-docker:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    # Needs permissions to write packages (GHCR)
    permissions:
      contents: read    # Needed for checkout
      packages: write   # Needed for ghcr push
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Validate Secrets
        run: |
          if [ -z "${{ secrets.DOCKER_HUB_USERNAME }}" ]; then
            echo "::error::DOCKER_HUB_USERNAME secret is not set"
            exit 1
          fi
          if [ -z "${{ secrets.DOCKER_HUB_TOKEN }}" ]; then
            echo "::error::DOCKER_HUB_TOKEN secret is not set"
            exit 1
          fi
          echo "Secrets validation passed"

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }} # Correct username for GHCR
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            # Docker Hub image name
            ${{ secrets.DOCKER_HUB_USERNAME }}/${{ env.IMAGE_NAME }}
            # GHCR image name
            ghcr.io/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}
          # This automatically generates appropriate tags:
          # - On 'v1.2.3' tag push: generates '1.2.3', 'latest'
          # - On manual trigger (often from main): generates 'main', 'latest' (if enabled for branch push)
          # Add flavor configuration if you need 'v' prefix on Docker tags
          # flavor:
          #   prefix=v,onlatest=true

      - name: Build and push Docker image
        id: build-push
        uses: docker/build-push-action@v5
        with:
          context: . # Assumes Dockerfile is in the root
          # Only push if it's a tag push OR a manual trigger (adjust if needed)
          push: ${{ github.event_name == 'push' || github.event_name == 'workflow_dispatch' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          # Add cache for faster builds
          cache-from: type=gha
          cache-to: type=gha,mode=max
          # Optional: Add build args if your Dockerfile needs them
          # build-args: |
          #   VERSION=${{ github.ref_name }}

      - name: Print Image Details
        if: steps.build-push.outputs.digest # Only print if digest was generated (i.e., build happened)
        run: |
          echo "Docker Image Tags: ${{ steps.meta.outputs.tags }}"
          echo "Docker Image Digest: ${{ steps.build-push.outputs.digest }}"


  # Job 3: Create GitHub Release (Depends on Go Build and Docker Push)
  create-release:
    name: Create GitHub Release
    needs: [build-go, build-and-push-docker] # Run after binaries and image are ready
    runs-on: ubuntu-latest
    # --- Permissions needed to create a release and upload assets ---
    permissions:
      contents: write
    # --- CRITICAL: Ensure this job ONLY runs for actual v* tag pushes ---
    # It checks the Git reference directly. Manual runs ('workflow_dispatch')
    # will have a different ref (like refs/heads/main) and will skip this job.
    if: startsWith(github.ref, 'refs/tags/v')
    # -------------------------------------------------------------------
    steps:
      # No code checkout needed here, we use artifacts and context vars

      - name: Download Go Binaries Artifact
        uses: actions/download-artifact@v4
        with:
          # Use the output from the build job to get the correct artifact name
          name: ${{ needs.build-go.outputs.binary_artifact_name }}
          path: ./release-assets # Download to a specific directory

      - name: List downloaded files # For debugging
        run: ls -R ./release-assets

      - name: Create Release Notes Body
        id: release_notes
        run: |
          # Get the tag name from the build job's output
          TAG_NAME="${{ needs.build-go.outputs.tag_name }}"

          # Construct the body for the release notes using Markdown
          cat << EOF > release_body.md
          ## Release Notes for ${TAG_NAME}

          Automated release for version ${TAG_NAME}.

          This release includes the compiled application binaries for Linux (amd64) and updated Docker images.

          **Docker Images:**
          *   Docker Hub: \`${{ secrets.DOCKER_HUB_USERNAME }}/${{ env.IMAGE_NAME }}:${TAG_NAME}\` (and potentially \`latest\`)
          *   GitHub Packages: \`ghcr.io/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${TAG_NAME}\` (and potentially \`latest\`)

          **Assets:**
          *   Compiled Linux (amd64) binary attached below.
          *   Source code archives (.zip/.tar.gz) automatically added by GitHub.

          *(You can add more detailed release notes here, perhaps generated from commit messages or a CHANGELOG)*
          EOF

          echo "Release notes generated in release_body.md"
          cat release_body.md # Print the notes for debugging

      - name: Create GitHub Release and Upload Binaries
        uses: softprops/action-gh-release@v1
        # Ensure environment has GITHUB_TOKEN
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          # Use the tag name from the build job output
          name: Release ${{ needs.build-go.outputs.tag_name }}
          tag_name: ${{ needs.build-go.outputs.tag_name }}
          # Use the generated notes file
          body_path: release_body.md
          # Use a glob pattern to upload all files downloaded into the assets directory
          files: ./release-assets/*
          draft: false
          prerelease: false # Set to true if your tag indicates a pre-release (e.g., v1.0.0-beta)
